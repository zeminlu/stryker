package tools;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import org.multijava.mjc.JCompilationUnitType;

import config.StrykerConfig;
import ar.edu.jdynalloy.JDynAlloySemanticException;
import ar.edu.taco.TacoAnalysisResult;
import ar.edu.taco.TacoMain;
import ar.edu.taco.TacoNotImplementedYetException;
import ar.edu.taco.engine.SnapshotStage;
import ar.edu.taco.engine.StrykerStage;
import ar.edu.taco.jml.parser.JmlParser;
import ar.edu.taco.junit.RecoveredInformation;
import repairer.FixCandidate;

/**
 * This class is used to access TACO, the main responsabilities of this API are:
 * 
 * <li> Given a java source file run SAT and return the result </li>
 * <li> Obtain the counter example built by SAT solver for a previous run that gave UNSAT </li>
 *
 * @author Nazareno Matías Aguirre
 * @author Simón Emmanuel Gutiérrez Brida
 * 
 * @see FixCandidate
 * @see CounterExample
 * 
 * @version 2.0
 */
public class TacoAPI {
	
	/**
	 * An instance of this class, used to implement the Singleton pattern
	 */
	private static TacoAPI instance = null;
	
	/**
	 * Access to Taco in comitaco
	 */
	private TacoMain wireToTaco = null;
	
	/**
	 * config file used by run method of {@code TacoMain}
	 */
	private String configFile = null;
	
	/**
	 * overriding properties used by run method of {@code TacoMain}
	 */
	private Properties overridingProperties = null;

	/**
	 * TODO: add comments
	 */
	private Map<FixCandidate, CounterExample> counterexamples;
	
	/**
	 * TODO: add comments
	 */
	private CounterExample lastCounterExample;
		
	/**
	 * Returns an instance of this class
	 * 
	 * @param configFile	:	config file used by run method of {@code TacoMain}	:	{@code String}
	 * @return an instance of this class
	 * @throws IllegalStateException if an instance is already built and this method is called with a different config file
	 */
	public static TacoAPI getInstance(String configFile) throws IllegalStateException {
		if (instance != null && instance.configFile.compareTo(configFile) != 0) {
			throw new IllegalStateException("TacoAPI instance is already built using config file : " + instance.configFile);
		}
		if (instance == null) instance = new TacoAPI(configFile, new Properties());
		return instance;
	}
	
	/**
	 * @return an instance of this class
	 */
	public static TacoAPI getInstance() {
		if (instance == null) {
			instance = new TacoAPI(StrykerConfig.DEFAULT_PROPERTIES, new Properties());
		}
		return instance;
	}
	
	/**
	 * Private constructor
	 * 
	 * @param configFile			:	config file used by run method of {@code TacoMain}				:	{@code String}
	 * @param overridingProperties	:	overriding properties used by run method of {@code TacoMain}	:	{@code Properties}
	 */
	private TacoAPI(String configFile, Properties overridingProperties) {
		this.configFile = configFile;
		this.overridingProperties = overridingProperties;
		this.wireToTaco = new TacoMain(null);
		this.counterexamples = new HashMap<FixCandidate, CounterExample>();
	}
	
	/**
	 * @return overriding properties used by run method of {@code TacoMain}
	 */
	public Properties getOverridingProperties() {
		return this.overridingProperties;
	}

	/**
	 * Runs SAT on a java source file
	 * @param candidate	:	the java source file	:	{@code FixCandidate}
	 * @return {@code true} if the SAT solver returns SAT, {@code false} if returns UNSAT	:	{@code boolean}
	 */
	public boolean isSAT(FixCandidate candidate) throws TacoNotImplementedYetException, JDynAlloySemanticException {
		if (this.counterexamples.containsKey(candidate)) {
			return !this.counterexamples.get(candidate).counterExampleExist();
		}
		TacoAnalysisResult result = null;
		try {
			result = this.wireToTaco.run(this.configFile, this.overridingProperties);
		}
		catch (TacoNotImplementedYetException e) {
			throw e;
		}
		catch (JDynAlloySemanticException e) {
			throw e; 
		}
		RecoveredInformation recoveredInformation = null;
		if (result.get_alloy_analysis_result().isSAT()) {
			List<JCompilationUnitType> compilation_units = JmlParser.getInstance().getCompilationUnits();
	        String classToCheck = candidate.getProgram().getClassName();
	        String methodToCheck = candidate.getMethodToFix() + "_0" ;
		    SnapshotStage snapshotStage = new SnapshotStage(compilation_units, result, classToCheck, methodToCheck);
		    snapshotStage.execute();
		    recoveredInformation = snapshotStage.getRecoveredInformation();
		    recoveredInformation.setFileNameSuffix(StrykerStage.fileSuffix);
		}
	    CounterExample ce = new CounterExample(recoveredInformation, result, candidate);
		this.lastCounterExample = ce;
		this.counterexamples.put(candidate, ce);
	    return ce.counterExampleExist();
	}
	
	/**
	 * @return the {@code CounterExample} generated by the last call to {@link TacoAPI#isSAT(FixCandidate)}	:	{@code CounterExample}
	 * @throws IllegalStateException if the method {@code TacoAPI#isSat(FixCandidate)} hasn't been called at least once
	 */
	public CounterExample getLastCounterExample() {
		if (this.lastCounterExample == null) {
			throw new IllegalStateException("TacoAPI#isSat(FixCandidate) must be called at least once before calling this method");
		}
		return this.lastCounterExample;
	}

	
	/**
	 * @param candidate	:	an instance of {@code FixCandidate} for which {@link TacoAPI#isSAT(FixCandidate)} has previously been called	:	{@code FixCandidate}
	 * @return a previously generated {@code CounterExample} for that candidate	:	{@code CounterExample}
	 * @throws IllegalStateException if the method {@code TacoAPI#isSat(FixCandidate)} hasn't been called before for {@code candidate}
	 */
	public CounterExample getCounterExample(FixCandidate candidate) {
		if (!this.counterexamples.containsKey(candidate)) {
			throw new IllegalStateException("TacoAPI#isSat(FixCandidate) hasn't been called for candidate");
		}
		return this.counterexamples.get(candidate);
	}

}
